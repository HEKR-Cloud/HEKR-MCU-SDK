C51 COMPILER V9.01   MAIN                                                                  06/27/2016 15:45:35 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: G:\new_windows\keil\C51\BIN\C51.EXE main.c LARGE BROWSE INCDIR(..\51 MDK) DEBUG OBJECTEXTEND TABS(2
                    -)

line level    source

   1          #include <reg52.h>        
   2          #include "hekr_protocol.h"
   3          
   4          #define USER_REV_BUFF_MAX_LEN   20  // æ ¹æ®å®žé™…æƒ…å†µè°ƒæ•´æŽ¥æ”¶bufferå¤§å°
   5          
   6          void InitUART(void);
   7          void SendByte(unsigned char dat);
   8          unsigned char xdata Recv_Buffer[USER_REV_BUFF_MAX_LEN];
   9          unsigned char Recv_STA = 0;
  10          
  11          unsigned char idata ProdKey[16] = {0x01,0x36,0xA6,0x6C,0x12,0x75,0x4E,0xE8,0x2F,0xFF,0x88,0x04,0xB7,0xFA,0
             -xA5,0x3C};         //äº§å“ç§˜é’¥è®¾ç½®ï¼Œå…±16ä¸ªå­—èŠ‚,å½“å‰ç¤ºä¾‹ProdKeyå€¼å¯¹åº”LEDå¤šå½©ä½“éªŒé¡µé¢ã€‚ProdKeyçš„è
             -Ž·å–å’Œè®¾ç½®æ–¹æ³•å¯å‚è€ƒï¼šhttp://docs.hekr.me/v4/resourceDownload/protocol/uart/#44prodkey
  12          
  13          /*------------------------------------------------
  14                              ä¸»å‡½æ•°
  15          ------------------------------------------------*/
  16          void main (void)
  17          {
  18   1        unsigned char temp = 0,UserValidLen = 9;
  19   1        InitUART();
  20   1        HekrInit(SendByte);
  21   1        HekrValidDataUpload(UserValidLen);
  22   1        
  23   1        /*************æ¨¡å—æ“ä½œå‡½æ•°************/
  24   1      
  25   1        Module_State_Function();               //æ¨¡å—çŠ¶æ€æŸ¥è¯¢
  26   1        Module_Soft_Reboot_Function();         //æ¨¡å—è½¯é‡å¯
  27   1        Module_Factory_Reset_Function();       //æ¨¡å—æ¢å¤å‡ºåŽ‚è®¾ç½®
  28   1        Hekr_Config_Function();                //æ¨¡å—è¿›å…¥ä¸€é”®é…ç½®
  29   1        Module_Set_Sleep_Function();           //æ¨¡å—è¿›å…¥ä¼‘çœ 
  30   1        Module_Weakup_Function();              //æ¨¡å—ä¼‘çœ å”¤é†’
  31   1        Module_Firmware_Versions_Function();   //æ¨¡å—ç‰ˆæœ¬æŸ¥è¯¢
  32   1        Module_ProdKey_Get_Function();         //æ¨¡å—äº§å“ç§˜é’¥ProdKeyæŸ¥è¯¢
  33   1        Module_Factory_Test_Function();        //æ¨¡å—è¿›å…¥åŽ‚æµ‹æ¨¡å¼
  34   1        Set_ProdKey(ProdKey);                  //æ¨¡å—ProdKeyè®¾ç½®ï¼Œç”¨æˆ·æ ¹æ®ä»Žconsoleå¹³å°èŽ·å–çš„ProdK
             -eyå€¼è®¾ç½®äº§å“ç§˜é’¥æ•°ç»„ProdKey[16]
  35   1      
  36   1        
  37   1        while(1)
  38   1        {
  39   2          if(Recv_STA)
  40   2          {
  41   3            temp = HekrRecvDataHandle(Recv_Buffer);
  42   3            if(ValidDataUpdate == temp)
  43   3            {
  44   4              //æŽ¥æ”¶çš„äº§å“ä¸šåŠ¡æ•°æ®ä¿å­˜åœ¨ valid_data æ•°ç»„é‡Œ
  45   4              /************äº§å“ä¸šåŠ¡æ•°æ®æ“ä½œç”¨æˆ·ä»£ç ********/
  46   4              SendByte(valid_data[0]);
  47   4              /********************************************/
  48   4            }
  49   3            if(HekrModuleStateUpdate == temp)
  50   3            {
  51   4              //æŽ¥æ”¶çš„æ¨¡å—çŠ¶æ€å–å€¼ä¿å­˜åœ¨ ModuleStatus æŒ‡é’ˆé‡Œ
C51 COMPILER V9.01   MAIN                                                                  06/27/2016 15:45:35 PAGE 2   

  52   4              /*************æ¨¡å—çŠ¶æ€æ“ä½œç”¨æˆ·ä»£ç ************/
  53   4              SendByte(ModuleStatus->Mode);           //æ‰“å°æ¨¡å—å·¥ä½œæ¨¡å¼æŒ‡ç¤ºå­—èŠ‚
  54   4              SendByte(ModuleStatus->WIFI_Status);    //æ‰“å°æ¨¡å—WIFIçŠ¶æ€æŒ‡ç¤ºå­—èŠ‚
  55   4              SendByte(ModuleStatus->CloudStatus);    //æ‰“å°æ¨¡å—äº‘è¿žæŽ¥çŠ¶æ€æŒ‡ç¤ºå­—èŠ‚
  56   4              SendByte(ModuleStatus->SignalStrength); //æ‰“å°æ¨¡å—çŠ¶æ€æŸ¥è¯¢åº”ç­”å¸§ä¿ç•™å­—èŠ‚
  57   4              /*************æ¨¡å—çŠ¶æ€å–å€¼å‚è€ƒï¼šhttp://docs.hekr.me/v4/resourceDownload/protocol/uart/#42  **
             -********/
  58   4            }
  59   3            Recv_STA = 0;   
  60   3          }
  61   2        }
  62   1      }
  63          
  64          void InitUART(void)
  65          {
  66   1        SCON  = 0x50;            
  67   1        TMOD |= 0x20;              
  68   1        //TH1   = 0XF3;             
  69   1        //TL1   = 0XF3;
  70   1        TH1   = 0XFA;     //æ™¶æŒ¯æœ‰è¯¯å·®        
  71   1        TL1   = 0XFA;     //æ™¶æŒ¯æœ‰è¯¯å·®
  72   1        PCON |= 0X80; 
  73   1        TR1   = 1;                                       
  74   1        EA    = 1;                  
  75   1        ES    = 1;                
  76   1      }         
  77          
  78          void SendByte(unsigned char dat)
  79          {
  80   1        SBUF = dat;
  81   1        while(!TI);
  82   1          TI = 0;
  83   1      }
  84          
  85          void UART_SER (void) interrupt 4 
  86          {
  87   1        unsigned char Temp;        
  88   1        static unsigned char count,flag = 0;
  89   1        
  90   1        if (RI)                      
  91   1        {
  92   2            RI = 0;                      
  93   2          Temp = SBUF;
  94   2      
  95   2          if (0 == flag)
  96   2          {
  97   3            if (HEKR_FRAME_HEADER == Temp)
  98   3            {
  99   4              count = 0;
 100   4              flag = 1;
 101   4              Recv_Buffer[count++] = Temp;
 102   4            }
 103   3          }
 104   2          else
 105   2          {
 106   3            if (USER_REV_BUFF_MAX_LEN > count)
 107   3            {
 108   4              Recv_Buffer[count++] = Temp;
 109   4              if((count > 4) && (count >= Recv_Buffer[1]))
 110   4              {
 111   5                Recv_STA = 1;
 112   5                flag = 0;
C51 COMPILER V9.01   MAIN                                                                  06/27/2016 15:45:35 PAGE 3   

 113   5                count = 0;
 114   5              }
 115   4            }
 116   3            else
 117   3            {
 118   4              flag = 0;
 119   4              count = 0;
 120   4            }
 121   3          }
 122   2        }
 123   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    346    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
